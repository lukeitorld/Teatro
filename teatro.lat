###############################################################################
# PROGRAMA: teatro.lat
# CREADO  : 05/01/2026
# VERSION : 0.42
# AUTOR   : Lukeitor
# OBJETIVO: Un módulo para hacer juegos de texto interactivo con la consola
# comtenarios: 
###############################################################################

estado = {
    "colores" : {"resetear":"\033[0m","negrita":"\033[1m","italicas":"\033[3m","subrayado":"\033[4m","parpadeo":"\033[5m","tachado":"\033[9m ","titulo":"\033[38;2;0;191;255m","subtitulo":"\033[38;2;30;58;138m","texto":"\033[38;2;192;192;192m","opciones":"\033[38;2;64;224;208m","exito":"\033[38;2;255;215;0m","mal":"\033[38;2;220;20;60m","resaltado":"\033[38;2;138;43;226m"},
    "configuracion" : {
        "ancho": 100
    },
    "historia" : [],
    "escena_actual" : {
        "nombre": "",
        "descripcion": "",
        "id": 0,
        "opciones": []
    },
    "escena_anterior" : {
        "nombre": "",
        "descripcion": "",
        "id": 0,
        "opciones": []
    }
}

metodos = {
    "cambiar_escena": funcion(escena)
        lista.agregar(estado.historia, estado.escena_actual)
        estado.escena_anterior.nombre = estado.escena_actual.nombre
        estado.escena_anterior.descripcion = estado.escena_actual.descripcion
        estado.escena_anterior.id = estado.escena_actual.id
        estado.escena_anterior.opciones = estado.escena_actual.opciones
        

        estado.escena_actual.nombre = escena.nombre
        estado.escena_actual.descripcion = escena.descripcion
        estado.escena_actual.id = escena.id
        estado.escena_actual.opciones = escena.opciones
        

        titulo = ""
        largo = mate.abs((estado.configuracion.ancho - cadena.longitud(estado.escena_actual.nombre))  / 2)
        bordes = ""
        si ((cadena.longitud(estado.escena_actual.nombre) + largo*2) >= estado.configuracion.ancho)
            largo = largo - 1
        fin
        repetir
            bordes = bordes.."="
        hasta (cadena.longitud(bordes)>=largo)
        titulo = bordes..estado.escena_actual.nombre..bordes
        
        /*
        cuerpo = ""
        longitud_total = cadena.longitud(estado.escena_actual.descripcion)
        desde (i = 0;i<longitud_total;i=i+estado.configuracion.ancho)
            fragmento = cadena.subcadena(estado.escena_actual.descripcion, i, estado.configuracion.ancho)
            fragmento_unoMas = cadena.subcadena(estado.escena_actual.descripcion, i + 1, estado.configuracion.ancho)
            si (cadena.contiene(fragmento, "\n"))
                cuerpo = cuerpo .. fragmento
            osi (cadena.longitud(fragmento) < estado.configuracion.ancho)
                cuerpo = cuerpo .. fragmento
            osi (cadena.termina_con(fragmento," ") || cadena.termina_con(fragmento_unoMas," "))
                cuerpo = cuerpo .. fragmento.."\n"
            sino
                cuerpo = cuerpo .. fragmento .."_\n"
            fin
            
        fin
        */
        

        
        limpiar()
        escribir (estado.colores.negrita..estado.colores.subrayado..estado.colores.titulo.."╞ "..titulo.."╣"..estado.colores.resetear)
        
        cuerpo = metodos.armar_cuerpo(escena.descripcion)
        escribir (estado.colores.texto..cuerpo..estado.colores.resetear)
        
        
        opciones_sin_comandos = metodos.procesar_opciones(escena.opciones)
        

        escribir (estado.colores.opciones..opciones_sin_comandos[0].."\n"..opciones_sin_comandos[1].."\n"..opciones_sin_comandos[2]..estado.colores.resetear)
    fin,
    "armar_cuerpo": funcion (descripcion)
        texto = ""
        ancho = estado.configuracion.ancho

        si (cadena.contiene(descripcion,"\n"))
            en_lista = cadena.separar(descripcion,"\n")
            num_renglones = lista.longitud(en_lista)

            desde (i=0; i<num_renglones; i++)
                largo = cadena.longitud(en_lista[i])
                desde (t=0; t<largo; t=t+ancho)
                    fragmento = cadena.subcadena(en_lista[i], t, ancho)
                    texto = texto .. fragmento .. "\n"
                fin
            fin

        sino
            longitud_total = cadena.longitud(descripcion)

            desde (i=0; i<longitud_total; i=i+ancho)
                fragmento = cadena.subcadena(descripcion, i, ancho)
                fragmento_unoMas = cadena.subcadena(descripcion, i+1, ancho)

                si (cadena.longitud(fragmento) < ancho)
                    texto = texto .. fragmento
                osi (cadena.termina_con(fragmento," ") || cadena.termina_con(fragmento_unoMas," "))
                    texto = texto .. fragmento .. "\n"
                sino
                    texto = texto .. fragmento .. "_\n"
                fin
            fin
        fin
        retorno texto
    fin,
    "procesar_opciones": funcion(opciones)
        op = ["a","b","c"]
        
        si cadena.contiene(opciones[0],">vacio<")
            op[0] = ""
        sino
            op[0] = "(1) "..cadena.subcadena(opciones[0],0,cadena.ultimo_indice(opciones[0],">") - 1)
        fin
        
        si cadena.contiene(opciones[1],">vacio<")
            op[1] = ""
        sino
            op[1] = "(2) "..cadena.subcadena(opciones[1],0,cadena.ultimo_indice(opciones[1],">") - 1)
        fin
        
        si cadena.contiene(opciones[2],">vacio<")
            op[2] = ""
        sino
            op[2] = "(3) "..cadena.subcadena(opciones[2],0,cadena.ultimo_indice(opciones[2],">") - 1)
        fin
        retornar op
    fin,
    "procesar_entrada": funcion(entrada)
        entr = acadena(entrada)
        si (cadena.contiene(entr,"1") || cadena.contiene(entr,"2") || cadena.contiene(entr,"3"))
            activo = verdadero
            mientras (activo)
                si (entrada == 1)
                    //escribir (teatro.estado.escena_actual.opciones[0])
                    metodos.procesar_opcion(estado.escena_actual.opciones[0])
                    activo = falso
                    romper
                osi (entrada == 2)
                    //escribir (teatro.estado.escena_actual.opciones[1])
                    metodos.procesar_opcion(estado.escena_actual.opciones[1])
                    activo = falso
                    romper
                osi (entrada == 3)
                    metodos.procesar_opcion(estado.escena_actual.opciones[2])
                    activo = falso
                    romper
                fin
            fin
        sino
            teatro.metodos.cambiar_escena(teatro.estado.escena_actual)
            escribir (teatro.estado.colores.mal.."Entrada incorrecta, recuerda que solo valen las entradas 1, 2 y 3."..teatro.estado.colores.resetear)
        fin
    fin,
    "procesar_opcion": funcion(opcion)
        //busca y ejecuta una función: >nombre_funcion<
        primer_indice = cadena.ultimo_indice(opcion,">") + 1
        num_caracteres = cadena.ultimo_indice(opcion,"<") - cadena.ultimo_indice(opcion,">") - 1
        //escribir ("La longitud es: ".. primer_indice)
        si (!cadena.contiene(opcion,"<"))
            escribir ("Entrada incorrecta, intenta de nuevo.")
            teatro.metodos.cambiar_escena(teatro.estado.escena_actual)
        osi (cadena.contiene(opcion,">vacio<"))
            teatro.metodos.cambiar_escena(teatro.estado.escena_actual)
            escribir (teatro.estado.colores.mal.."Entrada incorrecta, opción inválida"..teatro.estado.colores.resetear)
        sino
            comando = cadena.subcadena(opcion,primer_indice,num_caracteres)
            cadena.ejecutar(comando)
        fin
        //escribir ("el comando es "..comando)
    fin
}

/*//Para hacer pruebas
menu = {
    "nombre": "Menu Principal",
    "descripcion": "Este es un menú principal",
    "id": 0,
    "opciones": ["opción 1", "opción 2", "opción 3"]
    
}
metodos.cambiar_escena(menu)
*/


// Diccionario que se retorna y al cual se accede desde otros archivos
retornar {
    "estado": estado,
    "metodos": metodos
}
