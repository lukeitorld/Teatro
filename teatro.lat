###############################################################################
# PROGRAMA: Teatro 0.5
# CREADO  : Enero del 2026
# VERSION : 0.5
# AUTOR   : Lukeitor
# OBJETIVO: Un módulo para hacer juegos de texto interactivo con la consola.
# Github del proyecto: https://github.com/lukeitorld/Teatro <--Hay ejemplos de uso
###############################################################################
//Esta es la versión final, salvo que halya errores para corregir
//Errores sin solución: A veces el texto se va más allá de lo indicado por
//la configuración ancho. No lo pude arreglar.
/* Características:
    -Cargar escenas en la consola.
    -Cambiar la escena que se muestra.
    -Ejecutar métodos del módulo o funciones del juego al seleccionar una opción.
*/
estado = {
    "colores" : {"resetear":"\033[0m","negrita":"\033[1m","italicas":"\033[3m","subrayado":"\033[4m","parpadeo":"\033[5m","tachado":"\033[9m ","titulo":"\033[38;2;0;191;255m","subtitulo":"\033[38;2;30;58;138m","texto":"\033[38;2;192;192;192m","opciones":"\033[38;2;64;224;208m","exito":"\033[38;2;255;215;0m","mal":"\033[38;2;220;20;60m","resaltado":"\033[38;2;138;43;226m"},
    "configuracion" : {
        "ancho": 100
    },
    "historia" : [],
    "escena_actual" : {
        "nombre": "",
        "descripcion": "",
        "id": 0,
        "opciones": []
    },
    "escena_anterior" : {
        "nombre": "",
        "descripcion": "",
        "id": 0,
        "opciones": []
    }
}

metodos = {
    "cambiar_escena": funcion(escena)
        lista.agregar(estado.historia, estado.escena_actual)
        estado.escena_anterior.nombre = estado.escena_actual.nombre
        estado.escena_anterior.descripcion = estado.escena_actual.descripcion
        estado.escena_anterior.id = estado.escena_actual.id
        estado.escena_anterior.opciones = estado.escena_actual.opciones
        

        estado.escena_actual.nombre = escena.nombre
        estado.escena_actual.descripcion = escena.descripcion
        estado.escena_actual.id = escena.id
        estado.escena_actual.opciones = escena.opciones
        
        

        titulo = ""
        largo = mate.abs((estado.configuracion.ancho - cadena.longitud(estado.escena_actual.nombre))  / 2)
        bordes = ""
        si ((cadena.longitud(estado.escena_actual.nombre) + largo*2) >= estado.configuracion.ancho)
            largo = largo - 1
        fin
        repetir
            bordes = bordes.."="
        hasta (cadena.longitud(bordes)>=largo)
        titulo = bordes..estado.escena_actual.nombre..bordes
        

        
        limpiar()
        escribir (estado.colores.negrita..estado.colores.subrayado..estado.colores.titulo.."╞ "..titulo.."╣"..estado.colores.resetear)
        
        cuerpo = metodos.armar_cuerpo(escena.descripcion)
        escribir (estado.colores.texto..cuerpo..estado.colores.resetear)
        
        
        opciones_sin_comandos = metodos.procesar_opciones(escena.opciones)
        

        escribir (estado.colores.opciones..opciones_sin_comandos[0].."\n"..opciones_sin_comandos[1].."\n"..opciones_sin_comandos[2]..estado.colores.resetear)
    fin,
    "armar_cuerpo": funcion (descripcion)
        texto = ""
        ancho = estado.configuracion.ancho

        si (metodos.la_cadena_contiene(descripcion,"\n"))
            en_lista = metodos.separar_cadena(descripcion,"\n")
            num_renglones = lista.longitud(en_lista)

            desde (i=0; i<num_renglones; i++)
                largo = cadena.longitud(en_lista[i])
                desde (t=0; t<largo; t=t+ancho)
                    fragmento = cadena.subcadena(en_lista[i], t, ancho)
                    texto = texto .. fragmento .. "\n"
                fin
            fin
        sino
            longitud_total = cadena.longitud(descripcion)
            desde (i=0; i<longitud_total; i=i+ancho)
                fragmento = cadena.subcadena(descripcion, i, ancho)
                texto = texto .. fragmento .. "\n"
            fin
        fin
        retorno texto
    fin,
    "procesar_opciones": funcion(opciones)
        op = ["a","b","c"]
        
        si (cadena.contiene(opciones[0],">vacio<"))
            op[0] = ""
        sino
            op[0] = "(1) "..cadena.subcadena(opciones[0],0,cadena.ultimo_indice(opciones[0],">") - 1)
        fin
        
        si (cadena.contiene(opciones[1],">vacio<"))
            op[1] = ""
        sino
            op[1] = "(2) "..cadena.subcadena(opciones[1],0,cadena.ultimo_indice(opciones[1],">") - 1)
        fin
        
        si (cadena.contiene(opciones[2],">vacio<"))
            op[2] = ""
        sino
            op[2] = "(3) "..cadena.subcadena(opciones[2],0,cadena.ultimo_indice(opciones[2],">") - 1)
        fin
        retornar op
    fin,
    "procesar_entrada": funcion(entrada)
        entr = acadena(entrada)
        si (cadena.contiene(entr,"1") || cadena.contiene(entr,"2") || cadena.contiene(entr,"3"))
            activo = verdadero
            mientras (activo)
                si (entrada == 1)
                    //escribir (teatro.estado.escena_actual.opciones[0])
                    metodos.procesar_opcion(estado.escena_actual.opciones[0])
                    activo = falso
                    romper
                osi (entrada == 2)
                    //escribir (teatro.estado.escena_actual.opciones[1])
                    metodos.procesar_opcion(estado.escena_actual.opciones[1])
                    activo = falso
                    romper
                osi (entrada == 3)
                    metodos.procesar_opcion(estado.escena_actual.opciones[2])
                    activo = falso
                    romper
                fin
            fin
        sino
            teatro.metodos.cambiar_escena(teatro.estado.escena_actual)
            escribir (teatro.estado.colores.mal.."Entrada incorrecta, recuerda que solo valen las entradas 1, 2 y 3."..teatro.estado.colores.resetear)
        fin
    fin,
    "procesar_opcion": funcion(opcion)
        //busca y ejecuta una función: >nombre_funcion<
        primer_indice = cadena.ultimo_indice(opcion,">") + 1
        num_caracteres = cadena.ultimo_indice(opcion,"<") - cadena.ultimo_indice(opcion,">") - 1
        //escribir ("La longitud es: ".. primer_indice)
        si (!cadena.contiene(opcion,"<"))
            escribir ("Entrada incorrecta, intenta de nuevo.")
            teatro.metodos.cambiar_escena(teatro.estado.escena_actual)
        osi (cadena.contiene(opcion,">vacio<"))
            teatro.metodos.cambiar_escena(teatro.estado.escena_actual)
            escribir (teatro.estado.colores.mal.."Entrada incorrecta, opción inválida"..teatro.estado.colores.resetear)
        sino
            comando = cadena.subcadena(opcion,primer_indice,num_caracteres)
            cadena.ejecutar(comando)
        fin
        //escribir ("el comando es "..comando)
    fin,
    "la_cadena_contiene": funcion(texto, sub)
    longitud_texto = cadena.longitud(texto)
    longitud_sub = cadena.longitud(sub)

    desde (i = 0; i <= longitud_texto - longitud_sub; i = i + 1)
        fragmento = cadena.subcadena(texto, i, longitud_sub)
        si (fragmento == sub)
            retorno verdadero
        fin
    fin

    retorno falso
fin,
"separar_cadena": funcion(texto, separador)
    partes = []
    actual = ""

    longitud = cadena.longitud(texto)
    longitud_sep = cadena.longitud(separador)

    si longitud_sep == 0
        // si el separador está vacío, devolvemos el texto completo como única parte
        partes[0] = texto
        retorno partes
    fin

    i = 0
    mientras (i < longitud)
        // mirar un fragmento del tamaño del separador
        si (i + longitud_sep) <= longitud
            probe = cadena.subcadena(texto, i, longitud_sep)
        sino
            probe = "" // no hay suficiente texto para igualar el separador
        fin

        si (probe == separador)
            // “flush” del bloque acumulado
            idx = lista.longitud(partes)
            partes[idx] = actual
            actual = ""
            i = i + longitud_sep
        sino
            // agregar un solo carácter al bloque
            c = cadena.subcadena(texto, i, 1)
            actual = actual .. c
            i = i + 1
        fin
    fin

    // último fragmento: apendear por índice (evita agregar(...))
    si (cadena.longitud(actual) > 0) || (lista.longitud(partes) == 0)
        idx = lista.longitud(partes)
        partes[idx] = actual
    fin

    retorno partes
    fin
}

/*//Para hacer pruebas rápidas
menu = {
    "nombre": "Menu Principal",
    "descripcion": "Este es un menú principal",
    "id": 0,
    "opciones": ["opción 1", "opción 2", "opción 3"]
    
}
metodos.cambiar_escena(menu)
*/


// Diccionario que se retorna y al cual se accede desde otros archivos
retornar {
    "estado": estado,
    "metodos": metodos
}
